## Game scene - Main gameplay container
##
## This scene contains all gameplay systems and is the primary container for the game world.
## Loaded by Main scene or directly for testing purposes.
##
## Architecture Role:
## - Manages three core subsystems: World (game state), UI (player interface), Camera (viewport)
## - Implements AR4 composition-based entity architecture foundation
## - Provides integration points for EventBus (AR5) communication
## - Follows AR11 graceful error handling and AR18 null safety patterns
##
## Child Node Structure:
## - World (Node3D): Contains hex grid, entities, and game state (Epic 1+)
## - UI (CanvasLayer): HUD, menus, and player interaction (Epic 2+)
## - Camera (Camera3D): Pan/zoom controls and viewport management (Epic 1)
##
## Story 0.5 Additions:
## - EventBus connections for scene lifecycle events
## - Proper cleanup on _exit_tree
## - Scene loaded signal emission
##
## Future Integration Points:
## - Story 1.1: World node will host HexGrid system
## - Story 2.1: UI will display animal selection and stats
## - Story 1.3: Camera will implement touch pan/zoom controls
##
## @tutorial: See Architecture Doc - Game Scene Structure
class_name Game
extends Node


## References to core subsystem nodes
@onready var world: WorldManager = $World
@onready var ui: CanvasLayer = $UI
@onready var camera: Camera3D = $Camera
@onready var camera_controller: CameraController = $Camera/CameraController

## UI component references (Story 3-4)
## Note: Using Control type since uid files need to be generated by Godot editor
@onready var _build_button: Control = $UI/BuildButton
@onready var _building_menu_panel: Control = $UI/BuildingMenuPanel


## Track if scene has been fully initialized
var _initialized := false


## Initialize game scene and validate subsystems
## Implements AR11 error handling and AR18 null safety
func _ready() -> void:
	# AR18: Early return guard clause - verify node is in tree
	if not is_inside_tree():
		push_error("[Game] Node not in scene tree - initialization failed")
		return

	# AR11: Graceful error handling - validate subsystems
	if not _verify_subsystems():
		push_error("[Game] Critical subsystems missing - game cannot function")
		# AR11: Graceful degradation - continue but log error
		return

	# Connect to EventBus lifecycle signals (Story 0.5)
	_connect_eventbus_signals()

	# Configure Camera3D for game viewport
	_configure_camera()

	# Initialize camera controller with world manager (Story 1.3)
	_initialize_camera_controller()

	# Connect build button to building menu (Story 3-4)
	_connect_building_ui()

	# Mark as initialized
	_initialized = true

	# Log success using Logger if available (AR11: Use Logger autoload)
	if is_instance_valid(GameLogger):
		GameLogger.info("Game", "Game scene loaded successfully")
		GameLogger.info("Game", "World, UI, and Camera subsystems ready")
	else:
		print("[Game] Game scene loaded successfully")
		print("[Game] World, UI, and Camera subsystems ready")


## Cleanup when scene is being removed from tree
## Disconnects all EventBus signals to prevent memory leaks
func _exit_tree() -> void:
	# NOTE: EventBus.scene_unloading signal not yet defined in architecture
	# TODO: Add to EventBus when scene lifecycle events are implemented

	# Disconnect all EventBus signals (Story 0.5)
	_disconnect_eventbus_signals()

	# Disconnect build button (Story 3-4)
	if _build_button and _build_button.pressed.is_connected(_on_build_button_pressed):
		_build_button.pressed.disconnect(_on_build_button_pressed)

	if is_instance_valid(GameLogger):
		GameLogger.info("Game", "Game scene unloading - cleanup complete")


## Verify all required child nodes exist
## Returns true if World, UI, and Camera are present
func _verify_subsystems() -> bool:
	# AR18: Null safety - check all critical child nodes
	var all_valid := true

	if not world:
		push_error("[Game] World node missing - cannot render game state")
		all_valid = false

	if not ui:
		push_error("[Game] UI node missing - player cannot interact")
		all_valid = false

	if not camera:
		push_error("[Game] Camera node missing - cannot display viewport")
		all_valid = false

	return all_valid


## Connect to EventBus signals for scene lifecycle events
func _connect_eventbus_signals() -> void:
	# AR18: Null safety guard
	if not is_instance_valid(EventBus):
		push_warning("[Game] EventBus not available - cannot connect signals")
		return

	# Connect to game state signals with signal verification
	if EventBus.has_signal("game_paused"):
		EventBus.game_paused.connect(_on_game_paused)
	else:
		push_warning("[Game] EventBus missing 'game_paused' signal")

	if EventBus.has_signal("game_resumed"):
		EventBus.game_resumed.connect(_on_game_resumed)
	else:
		push_warning("[Game] EventBus missing 'game_resumed' signal")


## Disconnect from EventBus signals during cleanup
func _disconnect_eventbus_signals() -> void:
	# AR18: Null safety guard
	if not is_instance_valid(EventBus):
		return

	# Safely disconnect all signals
	if EventBus.game_paused.is_connected(_on_game_paused):
		EventBus.game_paused.disconnect(_on_game_paused)

	if EventBus.game_resumed.is_connected(_on_game_resumed):
		EventBus.game_resumed.disconnect(_on_game_resumed)


## Connect build button to building menu (Story 3-4)
func _connect_building_ui() -> void:
	# AR18: Null safety guard
	if not _build_button:
		push_warning("[Game] BuildButton missing - building menu cannot be opened")
		return

	if not _building_menu_panel:
		push_warning("[Game] BuildingMenuPanel missing - building menu cannot function")
		return

	# Connect build button press to open building menu
	_build_button.pressed.connect(_on_build_button_pressed)

	if is_instance_valid(GameLogger):
		GameLogger.info("Game", "Build button connected to building menu")


## Handle build button press
func _on_build_button_pressed() -> void:
	if _building_menu_panel:
		if _building_menu_panel.is_showing():
			_building_menu_panel.hide_menu()
		else:
			_building_menu_panel.show_menu()


## Configure Camera3D for mobile portrait viewport
func _configure_camera() -> void:
	# AR18: Null safety guard
	if not camera:
		return

	# Set camera as current for this scene
	camera.make_current()

	# Camera3D is positioned in game.tscn at (0, 50, 30) with isometric rotation
	# Position: Transform3D(1, 0, 0, 0, 0.707107, 0.707107, 0, -0.707107, 0.707107, 0, 50, 30)
	# This provides ~45Â° isometric view of the game world

	# TODO (Story 1-3): Implement camera pan (X/Z translation)
	# TODO (Story 1-4): Implement camera zoom (distance adjustment via position.y)
	# For now, camera configuration is handled by game.tscn

	if is_instance_valid(GameLogger):
		GameLogger.debug("Game", "Camera3D configured at position (%f, %f, %f)" % [camera.position.x, camera.position.y, camera.position.z])


## Initialize camera controller with world manager reference
## Story 1.3: Camera pan requires world bounds for clamping
func _initialize_camera_controller() -> void:
	# AR18: Null safety guard
	if not camera_controller:
		push_warning("[Game] CameraController missing - camera pan will not work")
		return

	if not world:
		push_warning("[Game] World missing - camera bounds cannot be calculated")
		return

	# Initialize camera controller with world manager reference
	camera_controller.initialize(world)

	if is_instance_valid(GameLogger):
		GameLogger.info("Game", "CameraController initialized with world bounds")


## Handle game pause event
func _on_game_paused() -> void:
	if is_instance_valid(GameLogger):
		GameLogger.debug("Game", "Game paused - subsystems notified")

	# Future: Pause animations, disable input, etc.


## Handle game resume event
func _on_game_resumed() -> void:
	if is_instance_valid(GameLogger):
		GameLogger.debug("Game", "Game resumed - subsystems notified")

	# Future: Resume animations, enable input, etc.


## Check if the game scene is fully initialized
## @return true if all subsystems are ready
func is_initialized() -> bool:
	return _initialized


## Get reference to World node for external access
## @return WorldManager node or null if not available
func get_world() -> WorldManager:
	return world


## Get reference to UI node for external access
## @return UI node or null if not available
func get_ui() -> CanvasLayer:
	return ui


## Get reference to Camera node for external access
## @return Camera node or null if not available
func get_camera() -> Camera3D:
	return camera
